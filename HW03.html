<!DOCTYPE html>
<html>
<head>
<style>
</style>
</head>
<body> 


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js">
</script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
<script type="text/javascript">


var renderer, camera , camera2, controls, scene, axes;
var stats;
var keyboard = new KeyboardState();
var balls = [], clock;
var truck;
var angle;
var thrust;
var pos = new THREE.Vector3();
var vel = new THREE.Vector3();
var force = new THREE.Vector3();
var obstacles = [], center;

var angle = 0;
var power = 5;
(function() {
  Math.clamp = function(val,min,max){
    return Math.min(Math.max(val,min),max);
    
  }})();
  
class Point2{
	constructor(x, y){
		this.x = x;
		this.y = y;
	}
}  

class Box2{
	constructor(min,max){
		this.min = min;
		this.max = max;
	}
}

class obstacle{
      constructor(pos, radius){
        this.pos = pos;
        this.r = radius;
        this.mesh = new THREE.Mesh(new THREE.CylinderGeometry( radius, radius, 16, 20 ), new THREE.MeshBasicMaterial());
        this.mesh.position.copy(pos);
        scene.add(this.mesh);
      }
      collision(car){
        let c = new Point2(0, 0);
	    let r = new Box2( new Point2(car.max[0], car.max[1]), new Point2(car.min[0], car.min[1]) );
        let normalMat = new THREE.Matrix3().getNormalMatrix( car.mesh.matrixWorld );
        let xR = new THREE.Vector3(1, 0, 0).applyMatrix3(normalMat).normalize();
        let yR = new THREE.Vector3(0, 0, 1).applyMatrix3(normalMat).normalize();
        c.x = this.pos.clone().sub(car.mesh.position).dot(xR);
        c.y = this.pos.clone().sub(car.mesh.position).dot(yR);
        let rad = this.r * this.r;
        r.max.x -= c.x; r.max.y -= c.y;
        r.min.x -= c.x; r.min.y -= c.y;
        if( r.max.x < 0  ){
          if(r.max.y < 0)
              return (r.max.x * r.max.x + r.max.y * r.max.y) < rad ? 1:0;
          else if(r.min.y > 0)
              return (r.max.x * r.max.x + r.min.y * r.min.y) < rad ? 7:0;
          else
              return Math.abs(r.max.x) < this.r ? 4:0;
        }
        else if( r.min.x > 0 ){
          if( r.max.y < 0 )
              return  (r.max.y * r.max.y + r.min.x * r.min.x) < rad ? 3:0;
          else if( r.min.y > 0 )
              return  (r.min.y * r.min.y + r.min.x * r.min.x) < rad ? 9:0;
          else
              return r.min.x < this.r ? 6:0;
        }
        else {
          if( r.max.y < 0 )
              return Math.abs(r.max.y) < this.r ? 2:0;
          else if( r.min.y > 0 )
              return r.min.y < this.r ? 8:0;
          else
              return 5;
        }
    }
}

init();
animate();

function loadCubemap() {


var path = 'cube/';
var format = '.jpg';


var urls = [
    path + 'posx' + format, path + 'negx' + format,
    path + 'posy' + format, path + 'negy' + format,
    path + 'posz' + format, path + 'negz' + format
];


var loader = new THREE.CubeTextureLoader();


loader.setCrossOrigin ('');
var cubeMap = loader.load(urls);

cubeMap.format = THREE.RGBFormat;

return cubeMap;

}


function render(){
	renderer.clear();
	let WW = window.innerWidth;
	let HH = window.innerHeight;
	renderer.setViewport(0,0,WW/2,HH);
	camera.aspect = WW/2 / HH;
	camera.updateProjectionMatrix();
	renderer.render (scene, camera);
	renderer.setViewport(WW/2,0,WW/2,HH);
	if(truck!=undefined){
		camera2.position.set(truck.position.x,80,truck.position.z);
		camera2.up.set(0,0,-1);
		camera2.lookAt(truck.position);
	}
	renderer.render (scene, camera2);
	
}

function init() {
  

   scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.z = 50;
      camera.position.y = 30;
	  camera2 = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
      light = new THREE.PointLight(0xffffff);
      light.position.set(100, 300, 200);
      scene.add(light);
      var light2 = new THREE.AmbientLight(0x808080); // soft white light
      scene.add(light2);
	  clock = new THREE.Clock();
	  var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
	  var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
	  var cylinder = new THREE.Mesh( geometry, material );
	  scene.add( cylinder );
	  
      var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
      scene.add(gridXZ);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x888888);
      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      document.body.appendChild(renderer.domElement);
	  renderer.autoClear = false;
	  readModel('Car', 20);
	  
	
	scene.background = loadCubemap();
  
}

function animate() {
  var dt = clock.getDelta();
  keyboard.update();
  
	
  
	if(truck != undefined){
		

		if (keyboard.pressed ('W')) {
			power *= 1.2;
		}
		if (keyboard.pressed ('S')) {
			power /= 1.2;
		}
		power = Math.clamp (power, 0, 80.0); 
		var angle_thrust = angle;
		if(keyboard.pressed("A"))
			angle_thrust += 0.3;
		if(keyboard.pressed("D"))
			angle_thrust -= 0.3;
	  
	  if (vel.length() > 0) {
		angle = Math.atan2(-vel.z, vel.x); // update orientation
	  }
	  thrust = new THREE.Vector3(1,0,0).multiplyScalar(power).applyAxisAngle(new THREE.Vector3(0,1,0), angle_thrust);
	  force.copy (thrust);
	  force.add(vel.clone().multiplyScalar(-2))

	  // eulers
	  vel.add(force.clone().multiplyScalar(dt));
	  pos.add(vel.clone().multiplyScalar(dt));
	  
	  truck.position.copy(pos);
	  truck.rotation.y = angle - Math.PI / 4 + 0.3;
	  
	  let coll;
        for(let i=0;i<obstacles.length;i++){
          coll = obstacles[i].collision(truck);
          if(coll){
            obstacles[i].mesh.material.color.set ('red');
            if(coll == 1 || coll == 2 || coll == 3){
              truck.collided(0, dt);
            }
            else if(coll == 7 || coll == 8 || coll == 9){
              truck.collided(1, dt);
            }
            else if(coll == 4 || coll == 5){
              truck.collided(2, dt);
            }
            else if(coll == 6){
              truck.collided(3, dt);
            }
          }
          else{
            obstacles[i].mesh.material.color.set ('green');
          }
        }
	  
	  camera.position.copy(truck.localToWorld(new THREE.Vector3(-50, 15, 25)));
	  camera.lookAt(truck.position);
  }
  

  requestAnimationFrame (animate);
  render();
  
}

function readModel(modelName, targetSize = 1) {
      var onProgress = function(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };
      var onError = function(xhr) {};
      var mtlLoader = new THREE.MTLLoader();
      mtlLoader.setPath('models/' + modelName + '/' );
      mtlLoader.load(modelName + '.mtl', function(materials) {
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath('models/' + modelName + '/');
        objLoader.load(modelName + '.obj', function(object) {
          let theObject = unitize(object, targetSize);
          theObject.rotation.y = Math.PI / 3 +0.1;
          theObject.name = modelName;
          truck  = theObject;
          scene.add(truck);
          
        }, onProgress, onError);
      });
}
	
function unitize(object, targetSize) {
     // find bounding box of 'object'
    var box3 = new THREE.Box3();
    box3.setFromObject(object);
    var size = new THREE.Vector3();
    size.subVectors(box3.max, box3.min);
    var center = new THREE.Vector3();
    center.addVectors(box3.max, box3.min).multiplyScalar(0.5);
	console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
    console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);
    // uniform scaling according to objSize
    var objSize = Math.max(size.x, size.y, size.z);
    var scaleSet = targetSize / objSize;
    var theObject = new THREE.Object3D();
    theObject.add(object);
    object.scale.set(scaleSet, scaleSet, scaleSet);
    object.position.set(-center.x * scaleSet, -center.y * scaleSet + size.y / 2 * scaleSet, -center.z * scaleSet);
    return theObject;
}
	
</script>
</body>
</html>
